const debug = false
const user_agent = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36'
const elements_to_disable = ['.notifications-placeholder', '.top-ads-container', '.fandom-sticky-header', 'div#WikiaBar', 'aside.page__right-rail',
  '.n-modal-container', 'div#moe-float-toc-container', 'div#moe-draw-float-button', 'div#moe-global-header', '.mys-wrapper',
  'div#moe-open-in-app', 'div#age-gate', ".va-variant-prompt", ".va-variant-prompt-mobile"]
const { resolve } = require('path')
require('dotenv').config({ path: resolve(__dirname, '../.env') })
const express = require('express')
const puppeteer = require(process.env.NODE_ENV === 'production' ? 'puppeteer' : 'puppeteer-core')
const compression = require('compression')
const fs = require('fs')
const uuid = require('uuid')
const cwd = process.cwd()
const cache_path = cwd + '/cache/'

if (debug) {
  if (fs.existsSync(cache_path)) {
    fs.rmSync(cache_path, { recursive: true, force: true });
  }
  fs.mkdirSync(cache_path)
}


const custom_css = `
span.heimu a.external, span.heimu a.external:visited, span.heimu a.extiw, span.heimu a.extiw:visited {
  color: #252525;}
.heimu, .heimu a, a .heimu, .heimu a.new {
  background-color: #cccccc;
  text-shadow: none;
}
.tabber-container-infobox ul.tabbernav {
  display: none;
}

.tabber-container-infobox .tabber .tabbertab {
  display: unset !important;
}
`


async function makeScreenshot(page, el) {
  await page.waitForNetworkIdle()
  await page.evaluate(() => {
    window.scroll(0, 0)
  })
  // await el.scrollIntoView()
  const contentSize = await el.boundingBox()
  const dpr = page.viewport().deviceScaleFactor || 1;
  const maxScreenshotHeight = Math.floor(8 * 1024 / dpr)
  const images = []
  // https://bugs.chromium.org/p/chromium/issues/detail?id=770769
  let total_content_height = contentSize.y
  console.log('contentsize: ' + contentSize.height)
  for (let ypos = contentSize.y; ypos < contentSize.height + contentSize.y; ypos += maxScreenshotHeight) {
    total_content_height += maxScreenshotHeight
    let content_height = maxScreenshotHeight
    if (total_content_height > contentSize.height + contentSize.y) {
      content_height = contentSize.height - total_content_height + maxScreenshotHeight + contentSize.y
    }
    await page.evaluate((xpos, ypos) => {
      window.scroll(xpos, ypos)
    }, contentSize.x, ypos)
    await page.waitForNetworkIdle()
    console.log(contentSize.x, ypos, contentSize.width, content_height)
    let r = await page.screenshot({
      type: 'jpeg', quality: 90, encoding: 'base64', clip: {
        x: contentSize.x,
        y: ypos,
        width: contentSize.width,
        height: content_height
      }
    });
    images.push(r)
  }
  return JSON.stringify(images)
}

async function addCountBox(page, selected_element, endtime) {
  return await page.evaluate((selected_element, endtime) => {
    t = document.createElement('span')
    t.className = 'bot-countbox'
    t.style = 'position: absolute;opacity: 0.2;'
    document.querySelector(selected_element).insertBefore(t, document.querySelector(selected_element).firstChild)
    countTime();
    function countTime() {
      var nowtime = new Date();
      var lefttime = parseInt((nowtime.getTime() - endtime) / 1000);
      document.querySelector(".bot-countbox").innerHTML = `Generated by akaribot in ${lefttime}s`;
      if (lefttime <= 0) {
        return;
      }
      setTimeout(countTime, 1000);
    }

  }, selected_element, endtime)
}


const app = express()
app.use(compression())
app.use(require('body-parser').json({
  limit: '10mb'
}));
(async () => {
  const browser = await puppeteer.launch({
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
    executablePath: process.env.NODE_ENV === 'production' ? undefined : process.env.CHROMIUM_PATH,
    headless: !debug,
  });
  app.post('/page', async (req, res) => {
    const page = await browser.newPage();
    try {
      const url = req.body.url
      const css = req.body.css
      await page.setViewport({
        width: 1280,
        height: 720
      })
      await page.goto(url, { waitUntil: "networkidle0" })
      if (css) {
        page.addStyleTag({ 'content': css })
      }

      let r = await page.screenshot({ type: 'jpeg', encoding: 'binary' });
      res.writeHead(200, {
        'Content-Type': 'image/jpeg',
        'Content-Length': r.length
      });
      res.end(r);
    } catch (e) {
      res.status(500).json({
        message: e.message,
        stack: e.stack
      })
      return
    } finally {
      if (!debug) { await page.close() }
    }
  })
  app.post('/', async (req, res) => {
    let width = ~~req.body.width || 500
    let height = ~~req.body.height || 1000
    let mw = req.body.mw
    let tracing = ~~req.body.tracing || false
    let tracing_json = cache_path + uuid.v4() + '.json'
    const page = await browser.newPage();
    if (tracing) {
      await page.tracing.start({ 'path': tracing_json })
    }
    try {
      await page.setViewport({
        width,
        height
      })
      let content = `<link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+HK&family=Noto+Sans+JP&family=Noto+Sans+KR&family=Noto+Sans+SC&family=Noto+Sans+TC&display=swap" rel="stylesheet"><style>html body {
        margin-top: 0px !important;
        font-family: 'Noto Sans SC', sans-serif;
    }
    
    :lang(ko) {
        font-family: 'Noto Sans KR', 'Noto Sans JP', 'Noto Sans HK', 'Noto Sans TC', 'Noto Sans SC', sans-serif;
    }
    
    :lang(ja) {
        font-family: 'Noto Sans JP', 'Noto Sans HK', 'Noto Sans TC', 'Noto Sans SC', 'Noto Sans KR', sans-serif;
    }
    
    :lang(zh-TW) {
        font-family: 'Noto Sans HK', 'Noto Sans TC', 'Noto Sans JP', 'Noto Sans SC', 'Noto Sans KR', sans-serif;
    }
    
    :lang(zh-HK) {
        font-family: 'Noto Sans HK', 'Noto Sans TC', 'Noto Sans JP', 'Noto Sans SC', 'Noto Sans KR', sans-serif;
    }
    
    :lang(zh-Hans), :lang(zh-CN), :lang(zh) {
        font-family:  'Noto Sans SC', 'Noto Sans HK', 'Noto Sans TC', 'Noto Sans JP', 'Noto Sans KR', sans-serif;
    }
    
    div.infobox div.notaninfobox{
        width: 100%!important;
        float: none!important;
        margin: 0 0 0 0!important;
    }
    
    table.infobox, table.infoboxSpecial, table.moe-infobox {
        width: 100%!important;
        float: unset!important;
        margin: 0 0 0 0!important;
    }</style>
    <meta charset="UTF-8">
    <body>
    ${req.body.content}
    </body>`
      await page.setContent(content, { waitUntil: 'networkidle0' });
      if (tracing) {
        await page.tracing.stop()
      }
      let selector = null
      if (mw) {
        selector = 'body > .mw-parser-output > *:not(script):not(style):not(link):not(meta)'
      } else {
        selector = 'body > *:not(script):not(style):not(link):not(meta)'
      }
      const el = await page.$(selector)
      const read = await makeScreenshot(page, el)
      res.writeHead(200, {
        'Content-Type': 'application/json',
        'Content-Length': read.length,
        'Tracing': tracing ? tracing_json : null
      });
      res.end(read)
    } catch (e) {
      res.status(500).json({
        message: e.message,
        stack: e.stack
      })
    } finally {
      if (!debug) { await page.close() }
    }

  })
  app.post('/element_screenshot', async (req, res) => {
    let width = ~~req.body.width || 720
    let height = ~~req.body.height || 1280
    let element = req.body.element
    let content = req.body.content
    let url = req.body.url
    let counttime = req.body.counttime
    let tracing = req.body.tracing || false
    let css = req.body.css
    let tracing_json = cache_path + uuid.v4() + '.json'
    const page = await browser.newPage();
    if (tracing) {
      await page.tracing.start({ 'path': tracing_json })
    }
    try {
      var endtime = (new Date()).getTime()
      await page.setViewport({
        width,
        height
      })
      if (content) {
        await page.setContent(content, { waitUntil: 'networkidle0' });
      } else if (url) {
        await page.setUserAgent(user_agent)
        await page.goto(url, { waitUntil: "networkidle0", timeout: 0 })
      } else {
        res.status(500).json({
          message: 'A url or content must be specified.'
        })
        return
      }
      await page.addStyleTag({ 'content': custom_css })
      if (css) {
        page.addStyleTag({ 'content': css })
      }

      await page.evaluate((elements_to_disable) => {

        const lazyimg = document.querySelectorAll(".lazyload")
        for (var i = 0; i < lazyimg.length; i++) {
          lazyimg[i].className = 'image'
          lazyimg[i].src = lazyimg[i].getAttribute('data-src')
        }
        const animated = document.querySelectorAll(".animated")
        for (var i = 0; i < animated.length; i++) {
          b = animated[i].querySelectorAll('img')
          for (ii = 0; ii < b.length; ii++) {
            b[ii].width = b[ii].getAttribute('width') / (b.length / 2)
            b[ii].height = b[ii].getAttribute('height') / (b.length / 2)
          }
          animated[i].className = 'nolongeranimatebaka'
        }
        for (var i = 0; i < elements_to_disable.length; i++) {
          const element_to_boom = document.querySelector(elements_to_disable[i])// :rina: :rina: :rina: :rina:
          if (element_to_boom != null) {
            element_to_boom.style = 'display: none'
          }
        }
        document.querySelectorAll('*').forEach(element => {
          element.parentNode.replaceChild(element.cloneNode(true), element);
        });
        window.scroll(0, 0)
      }, elements_to_disable)

      let selected_element = null

      if (Array.isArray(element)) {
        for (var i = 0; i < element.length; i++) {
          var el = await page.$(element[i])
          if (el != null) {
            selected_element = element[i]
            break
          }
        }
      } else {
        selected_element = element
        var el = await page.$(element)
      }
      if (el == null) {
        res.status(500).json({
          message: 'No given elements matches the selector.'
        })
        return
      }
      if (counttime == null || counttime == true) {
        await addCountBox(page, selected_element, endtime)
      }

      page.addStyleTag({ 'content': `${selected_element} {z-index: 99999999999999999999999999999}` })

      if (tracing) {
        await page.tracing.stop()
      }

      const read = await makeScreenshot(page, el)
      res.writeHead(200, {
        'Content-Type': 'application/json',
        'Content-Length': read.length,
        'Tracing': tracing ? tracing_json : null
      });
      res.end(read)
    } catch (e) {
      res.status(500).json({
        message: e.message,
        stack: e.stack
      })
    } finally {
      if (!debug) { await page.close() }
    }
  })
  app.post('/section_screenshot', async (req, res) => {
    let width = ~~req.body.width || 1920
    let height = ~~req.body.height || 1080
    let section = req.body.section
    let content = req.body.content
    let url = req.body.url
    let counttime = req.body.counttime
    let tracing = ~~req.body.tracing || false
    let css = req.body.css
    let tracing_json = cache_path + uuid.v4() + '.json'
    const page = await browser.newPage();
    if (tracing) {
      await page.tracing.start({ 'path': tracing_json })
    }
    try {
      var endtime = (new Date()).getTime()
      await page.setViewport({
        width,
        height
      })
      if (content) {
        await page.setContent(content, { waitUntil: 'networkidle0' });
      } else if (url) {
        await page.setUserAgent(user_agent)
        await page.goto(url, { waitUntil: "networkidle0" })
      } else {
        res.status(500).json({
          message: 'A url or content must be specified.'
        })
        return
      }
      await page.addStyleTag({ 'content': custom_css })
      if (css) {
        page.addStyleTag({ 'content': css })
      }

      await page.evaluate((section, elements_to_disable) => {
        const levels = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6']
        let sec = document.getElementById(section).parentNode
        const sec_level = sec.tagName
        if (sec.parentNode.className.includes('ext-discussiontools-init-section')) { // wo yi ding yao sha le ni men
          sec = sec.parentNode
        }
        const nbox = document.createElement('div')
        nbox.className = 'bot-sectionbox'
        nbox.style = 'display: inline-block; padding: 15px'
        nbox.appendChild(sec.cloneNode(true))
        let next_sibling = sec.nextSibling
        while (next_sibling) {
          if (levels.includes(next_sibling.tagName)) {
            if (levels.indexOf(next_sibling.tagName) <= levels.indexOf(sec_level)) {
              break
            }
          }
          if (next_sibling.tagName == 'DIV' && next_sibling.className.includes('ext-discussiontools-init-section')) { // wo yi ding yao sha le ni men
            let child = next_sibling.firstChild
            let bf = false
            while (child) {
              if (levels.includes(child.tagName)) {
                if (levels.indexOf(child.tagName) <= levels.indexOf(sec_level)) {
                  bf = true
                  break
                }
              }
              child = child.nextSibling
            }
            if (bf) {
              break
            }


          }
          nbox.appendChild(next_sibling.cloneNode(true))
          next_sibling = next_sibling.nextSibling
        }
        const lazyimg = nbox.querySelectorAll(".lazyload")
        for (var i = 0; i < lazyimg.length; i++) {
          lazyimg[i].className = 'image'
          lazyimg[i].src = lazyimg[i].getAttribute('data-src')
        }
        const new_parentNode = sec.parentNode.cloneNode()
        const pparentNode = sec.parentNode.parentNode
        pparentNode.removeChild(sec.parentNode)
        pparentNode.appendChild(new_parentNode)
        new_parentNode.appendChild(nbox)
        for (var i = 0; i < elements_to_disable.length; i++) {
          const element_to_boom = document.querySelector(elements_to_disable[i])// :rina: :rina: :rina: :rina:
          if (element_to_boom != null) {
            element_to_boom.style = 'display: none'
          }
        }
        document.querySelectorAll('*').forEach(element => {
          element.parentNode.replaceChild(element.cloneNode(true), element);
        });
        window.scroll(0, 0)
      }, section, elements_to_disable)


      let el = await page.$('.bot-sectionbox')
      if (el == null) {
        res.status(500).json({
          message: 'No given elements matches the selector.'
        })
        return
      }

      if (counttime == null || counttime == true) {
        await addCountBox(page, '.bot-sectionbox', endtime)
      }

      page.addStyleTag({ 'content': `.bot-sectionbox {z-index: 99999999999999999999999999999}` })
      el = await page.$('.bot-sectionbox')
      const read = await makeScreenshot(page, el)

      if (tracing) {
        await page.tracing.stop()
      }


      res.writeHead(200, {
        'Content-Type': 'application/json',
        'Content-Length': read.length,
        'Tracing': tracing ? tracing_json : null
      });
      res.end(read)
    } catch (e) {
      res.status(500).json({
        message: e.message,
        stack: e.stack
      })
    } finally {
      if (!debug) { await page.close() }
    }
  })
  app.get('/source', async (req, res) => {
    const page = await browser.newPage();
    try {
      await page.setUserAgent(user_agent)
      const url = req.query.url
      await page.setViewport({
        width: 1280,
        height: 720
      })
      const r = await page.goto(url, { waitUntil: "networkidle0" })
      if (r.headers()['content-type']) {
        res.setHeader('content-type', r.headers()['content-type'])
      }
      res.send(await r.buffer())
    } catch (e) {
      res.status(500).json({
        message: e.message,
        stack: e.stack
      })
    } finally {
      if (!debug) { await page.close() }
    }
  })
  const server = app.listen(~~process.env.FC_SERVER_PORT || 15551)
  server.timeout = 0
  server.keepAliveTimeout = 0
})()
